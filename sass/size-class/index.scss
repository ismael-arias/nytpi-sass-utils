@import "./parser";
@import "../number-functions";

$susy: (
	use-custom: (
		px: true,
		em: true,
		rem: true
	)
);

// Loads and parses the Size Class v3 configuration,
// setting the parsed config to the global #. One-time use.
@mixin init-size-class-config($load-options...) {
	@if global-variable-exists(size-class-config) {
		@error "Size Class config has already been initialized.";
	} @else {
		$loaded-config: _load-size-class-config($load-options...);
		$size-class-config: _parse-size-class-config($loaded-config) !global;
	}
}

@mixin emulate-size-class-v2 {
	@include init-size-class-config("nytpi-v2-emulation.json", $replace: true);
}

// Throw an error if the size-class mixin already exists (prevent simultaneous loading with Size Class v2)
@if mixin-exists(size-class) {
	@error "size-class() mixin already exists --- Size Class v2.0 may have been imported already";
}

@function size-class-config-has-key($keys...) {
	@if not global-variable-exists(size-class-config) {
		@error "Size Class config has not been initialized.";
	}
	@return _susy-deep-has-key($size-class-config, $keys...);
}

// Getter function for the global $size-class-config map.
@function size-class-config-get($keys...) {
	@if not global-variable-exists(size-class-config) {
		@error "Size Class config has not been initialized.";
	}
	@return _susy-deep-get($size-class-config, $keys...);
}

// Setter function for the global $size-class-config map.
@mixin size-class-config-set($keys...) {
	@if not global-variable-exists(size-class-config) {
		@error "Size Class config has not been initialized.";
	}
	$size-class-config: _susy-deep-set($size-class-config, $keys...) !global;
}

@function get-config-pixel-grid-ratio() {
	$layout-types: size-class-config-get(options, layout-types);

	$_return: 1;

	@if index($layout-types, pixel-grid) and size-class-config-has-key(options, config-pixel-grid-ratio) {
		$_return: size-class-config-get(options, config-pixel-grid-ratio);
	}

	@return $_return;
};

@function get-pixel-grid-ratio() {
	$layout-types: size-class-config-get(options, layout-types);

	$_return: 1;

	@if index($layout-types, pixel-grid) and size-class-config-has-key(options, pixel-grid-ratio) {
		$_return: size-class-config-get(options, pixel-grid-ratio);
	}

	@return $_return;
};

@mixin set-pixel-grid-ratio($new-ratio) {
	@if type-of($new-ratio) != number or $new-ratio <= 0 {
		@error "Cannot set pixel-grid-ratio to a non-number or a number <= 0."
	}

	@include size-class-config-set(options, pixel-grid-ratio, $new-ratio);
}

@function get-pixel-grid-width($options) {
	$_return: null;

	$config-name: null;
	$min-or-max: null;
	$unit: null;

	$allowed-min-max: (min max);

	$allowed-units: (px em rem);

	@if length($options) > 3 {
		@error "Too many arguments passed to get-pixel-grid-width()";
	}

	// Parse $options
	@each $option in $options {
		// Is this option a size class or size family name?
		@if size-class-config-has-key(families, $option) or size-class-config-has-key(classes, $option) {
			$config-name: $option;
		}
		@else if type-of($option) == string {
			@debug $option + " is either a unit or min-or-max argument";
			// Is this option possibly a unit?
			@if index($allowed-units, $option) {
				@debug $option + " is a unit";
				$unit: $option;
			}
			@else if index($allowed-min-max, $option) {
				@debug $option + " is a min-or-max";
				$min-or-max: $option;
			}
			@else {
				@error "get-pixel-grid-width() passed an unsupported string argument (" + $option + ")";
			}
		}
	}

	// Get a size class's width
	@if type-of($min-or-max) != string {
		// If $config-name is null, try to get the size-class from $size-class-context
		@if $config-name == null {
			@if global-variable-exists(size-class-context) and map-has-key($size-class-context, size-class) {
				$config-name: map-get($size-class-context, size-class);
			}
			@else {
				@error "Could not get current size-class from $size-class-context.";
			}
		}
		// Is $config-name a family name?
		@else if size-class-config-has-key(families, $config-name) {
			// Get the size class for this family
			$config-name: size-class-config-get(families, $config-name, size-class);
		}
			// Otherwise, is this not a known size class?
		@else if not size-class-config-has-key(classes, $config-name) {
			@error $config-name + " is neither a known size family or size class name.";
		}

		// Check to see if we have a pixel-grid layout type
		$layout-types: size-class-config-get(options, layout-types);

		@if index($layout-types, pixel-grid) {
			$_return: size-class-config-get(classes, $config-name, pixel-grid, columns);
		} @else {
			@error "Size Class config does not contain a 'pixel-grid' layout type.";
		}
	}
	// Get a breakpoint's min-width or max-width
	@else {
		// If $config-name is null, get the target media query from the current context
		@if $config-name == null {
			@if global-variable-exists(size-class-context) and _susy-deep-has-key($size-class-context, target-media-query, #{$min-or-max}-width) {
				$_return: _susy-deep-get($size-class-context, target-media-query, #{$min-or-max}-width);
			} @else {
				@error "Could not get target-media-query's " + #{$min-or-max}-width + " from $size-class-context.";
			}
		}
		// $config-name is a breakpoint...so let's see if that exists
		@else if size-class-config-has-key(breakpoints, $config-name, #{$min-or-max}-width) {
			// Okay then, try to get the breakpoint config
			$_return: size-class-config-get(breakpoints, $config-name, #{$min-or-max}-width);
		}
		@else {
			@error $config-name + " is not a known breakpoint (or does not have a '" + #{$min-or-max}-width + "' property).";
		}
	}

	// Cover breakpoint value returns
	@if unit($_return) == px {
		// Convert px to unitless value
		$_return: $_return / 1px * get-config-pixel-grid-ratio();
	}

	// Convert unit to final desired unit
	@if unitless($_return) {
		// Do we need to do unit conversion?
		@if $unit != null {
			// Prefer the nytpi-s
			@if function-exists(_nytpi-sass-utils-#{$unit}) {
				$_return: call(_nytpi-sass-utils-#{$unit}, $_return);
			} @else if function-exists($unit) {
				$_return: call($unit, $_return);
			}
			@else {
				// We need to do some scaling
				$_return: $_return / get-config-pixel-grid-ratio();

				// If no function exists, need to apply pixel-ratio to the output
				@if $unit == px {
					$_return: $_return * 1px;
				}
				@else if $unit == em {
					$_return: $_return * 1em;
				} @else if $unit == rem {
					$_return: $_return * 1rem;
				}
			}
		} @else {
			// We need to do some different scaling to take both config-pixel-grid-ratio and pixel-grid-ratio into account
			$_return: $_return / (get-config-pixel-grid-ratio() / get-pixel-grid-ratio());
		}
	} @else {
		@error "Internal error in get-pixel-grid-width()";
	}

	@return $_return;
};

// $options examples:
// `desktop` (single size class)
// `desktop to mobile-portrait` (downscale range)
// `mobile-portrait to desktop` (upscale range)
// `desktop from tablet-portrait to tablet-landscape` (explicit layout for order-insensitive range)

@mixin size-class(
	$options,
	$no-query: $susy-media-fallback
) {
	// Load the default config if $size-class-config hasn't already been declared
	@if not global-variable-exists(size-class-config) {
		@include init-size-class-config();
	}

	// Parse the $options argument
	$parsed-options: ();

	// Check to see if $options is a string specifying a family name
	@if type-of($options) == string and _susy-deep-has-key($size-class-config, families, $options) {
		// $options is the name of a size family
		//@debug "$options: " + $options + " is a size family; using the size family's settings";
		$parsed-options: size-class-config-get(families, $options);
	}
	// $options is a shorthand expression or map instead
	@else {
		//@debug "$options: " + $options + " is a shorthand expression or something else; parsing it";
		$parsed-options: _parse-size-classes-shorthand($options, $size-class-config);
	}

	// Get the media query
	$target-media-query: _get-susy-media-query-for-options($parsed-options, $size-class-config);

	// Get the layout
	$target-layout: _get-layout-for-options($parsed-options, $size-class-config);

	// Add $target-media-query to $parsed-options
	$parsed-options: map-merge($parsed-options, (target-media-query: $target-media-query));

	// Reassign $size-class-context in this scope and restore it once we're done
	@if global-variable-exists(size-class-context) {
		$old-size-class-context: $size-class-context;
	}
	$size-class-context: $parsed-options !global;

	// Apply the media query and layout
	@if length($target-media-query) > 0 {
		@include susy-breakpoint(
			$query: $target-media-query,
			$layout: $target-layout,
			$no-query: $no-query
		) {
			/* Conditional Layout: inspect($target-layout) */
			@content;
		}
	} @else {
		@include with-layout($target-layout) {
			/* Unconditional Layout: inspect($target-layout) */
			@content;
		}
	}

	// Restore old value of $size-class-context
	@if variable-exists(old-size-class-context) {
		$size-class-context: $old-size-class-context !global;
	} @else {
		$size-class-context: () !global;
	}
}

// Applies the Size Class outer-margin option and calls the Susy container() mixin
@mixin size-class-container($prop: padding, $use-shorthand: false, $call-susy-container-mixin: true) {
	// Load the default config if $size-class-config hasn't already been declared
	@if not global-variable-exists(size-class-config) {
		@include init-size-class-config();
	}

	// Validate the $prop argument
	$supported-props: (padding margin);

	@if index($supported-props, $prop) == null {
		@error "$prop = " + $prop + " is not supported. Supported properties: " + $supported-props;
	}

	// Get value of the Size Class config's `outer-margin` option
	$outer-margin-value: size-class-config-get(options, outer-margin);

	// If $outer-margin-value is a unitless number less than or equal to 1...
	@if unitless($outer-margin-value) and $outer-margin-value <= 1 {
		// Convert $outer-margin-value to a percentage
		$outer-margin-value: $outer-margin-value * 100%;
	}

	// Output either a shorthand or non-shorthand properties with the outer margin value
	@if $use-shorthand {
		#{$prop}: 0 $outer-margin-value;
	} @else {
		#{$prop}-left: $outer-margin-value;
		#{$prop}-right: $outer-margin-value;
	}

	// Call the Susy container() mixin if we're supposed to
	@if $call-susy-container-mixin {
		@include container;
	}
}
