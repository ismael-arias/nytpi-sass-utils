// Import the NYTPI Default Config
@import "nytpi-default";

// Loads and parses the Size Class v3 configuration,
// setting the parsed config to the global #. One-time use.
@mixin init-size-class-config($load-options...) {
	@if global-variable-exists(size-class-config) {
		@error "Size Class config has already been initialized.";
	} @else if variable-exists(_nytpi-default-size-class-config) {
		// Note: Previously used Eyeglass function named _load-size-class-config()
		// to load the configuration.
		// $loaded-config: _load-size-class-config($load-options...);
		// NOTE: Using plain ol' SCSS below to load in the config file...
		$loaded-config: $_nytpi-default-size-class-config;
		$size-class-config: _parse-size-class-config($loaded-config) !global;
		$size-class-debug: false !global;
		$size-class-contexts-in-use: () !global;
	} @else {
		@error "Cannot import the nytpi-default configuration for Size Class v3 (_nytpi-default.scss).";
	}
}

@function get-config-pspx-ratio() {
	$layout-types: size-class-config-get(options, layout-types);

	$_return: 1;

	@if size-class-config-has-layout-type(pspx) and size-class-config-has-key(options, config-pspx-ratio) {
		$_return: size-class-config-get(options, config-pspx-ratio);
	}

	@return $_return;
};

@function get-pspx-ratio() {
	$layout-types: size-class-config-get(options, layout-types);

	$_return: 1;

	@if index($layout-types, pspx) and size-class-config-has-key(options, pspx-ratio) {
		$_return: size-class-config-get(options, pspx-ratio);
	}

	@return $_return;
};

@mixin set-pspx-ratio($new-ratio) {
	@if type-of($new-ratio) != number or $new-ratio <= 0 {
		@error "Cannot set pspx-ratio to a non-number or a number <= 0."
	}
		// Load the default config if $size-class-config hasn't already been declared
	@else if not global-variable-exists(size-class-config) {
		@include init-size-class-config();
	}

	@include size-class-config-set(options, pspx-ratio, $new-ratio);
}

@function _convert-unitless-to-unit($value, $unit, $context: null) {
	$_return: $value;

	// Convert unit to final desired unit
	@if unitless($_return) {
		// Do we need to do unit conversion?
		@if $unit != null {
			// Prefer the nytpi-sass-utils number functions
			@if function-exists(_nytpi-sass-utils-#{$unit}) {
				$_return: call(_nytpi-sass-utils-#{$unit}, $_return, $context);
			} @else if function-exists($unit) {
				$_return: call($unit, $_return, $context);
			}
			@else {
				// We need to do some scaling
				$_return: $_return / get-config-pspx-ratio();

				// If no function exists, need to apply pixel-ratio to the output
				@if $unit == px {
					$_return: $_return * 1px;
				}
				@else if $unit == em {
					$_return: $_return * 1em;
				}
				@else if $unit == rem {
					$_return: $_return * 1rem;
				}
				@else if $unit == vw {
					@error "Internal error in get-pspx-width(): cannot return vw unit value since _nytpi-sass-utils-vw() function doesn't exist.";
				}
			}
		}
	} @else {
		@error "_convert-unitless-to-unit() function passed a value with units: " + $value;
	}

	@return $_return;
}


@function get-outer-margin() {
	// Get value of the Size Class config's `outer-margin` option
	$outer-margin-value: size-class-config-get(options, outer-margin);

	// If $outer-margin-value is a unitless number less than or equal to 1...
	@if unitless($outer-margin-value) and $outer-margin-value <= 1 {
		// Convert $outer-margin-value to a percentage
		$outer-margin-value: $outer-margin-value * 100%;
	}

	@return $outer-margin-value;
}

@mixin _size-class-apply-outer-margin-to-element($prop, $use-prop-shorthand: false, $important: false) {
	// Validate the $prop argument
	$supported-props: (padding margin position);

	@if index($supported-props, $prop) == null {
		@error "$prop = " + $prop + " is not supported. Supported properties: " + $supported-props;
	}

	// Get value of the Size Class config's `outer-margin` option
	$outer-margin-value: get-outer-margin();

	// Output either a shorthand or non-shorthand properties with the outer margin value
	@if $prop != position {
		@if $use-prop-shorthand {
			#{$prop}: 0 $outer-margin-value if($important, !important, null);
		} @else {
			#{$prop}-left: $outer-margin-value if($important, !important, null);
			#{$prop}-right: $outer-margin-value if($important, !important, null);
		}
	} @else {
		left: $outer-margin-value if($important, !important, null);
		right: $outer-margin-value if($important, !important, null);
	}
}

@mixin size-class-debug($debug-output: background) {
	// Load the default config if $size-class-config hasn't already been declared
	@if not global-variable-exists(size-class-config) {
		@include init-size-class-config();
	}

	$size-class-debug: true !global;

	@if $debug-output != background and $debug-output != overlay {
		@error "size-class-debug() only accepts 'overlay' and 'background' as inputs.";
	}

	@include susy-set(debug, image, show);
	@include susy-set(debug, output, $debug-output);
	@include susy-set(debug, toggle, bottom left);
}

@mixin size-class-debug-disable() {
	$size-class-debug: false !global;

	@include susy-set(debug, image, hide);
	@include susy-set(debug, output, background);
	@include susy-set(debug, toggle, top right);
}

@mixin emulate-size-class-v2 {
	@include init-size-class-config("nytpi-v2-emulation.json", $replace: true);
}


@function size-class-config-has-layout-type($layout-type) {
	$layout-types: _susy-deep-get($size-class-config, options, layout-types);

	@return index($layout-types, $layout-type);
}

@function size-class-config-has-key($keys...) {
	@if not global-variable-exists(size-class-config) {
		@error "Size Class config has not been initialized.";
	}
	@return _susy-deep-has-key($size-class-config, $keys...);
}

// Getter function for the global $size-class-config map.
@function size-class-config-get($keys...) {
	@if not global-variable-exists(size-class-config) {
		@error "Size Class config has not been initialized.";
	}
	@return _susy-deep-get($size-class-config, $keys...);
}

// Setter function for the global $size-class-config map.
@mixin size-class-config-set($keys...) {
	@if not global-variable-exists(size-class-config) {
		@error "Size Class config has not been initialized.";
	}
	$size-class-config: _susy-deep-set($size-class-config, $keys...) !global;
}

@function get-pspx-width($options: ()) {
	$_return: null;

	$config-name: null;
	$min-or-max: null;
	$unit: null;

	$allowed-min-max: (min max);

	$supported-units: (px em rem vw);

	@if length($options) > 3 {
		@error "Too many arguments passed to get-pspx-width()";
	}

	// Parse $options
	@each $option in $options {
		// Is this option a size class or size family name?
		@if size-class-config-has-key(families, $option) or size-class-config-has-key(classes, $option) {
			$config-name: $option;
		}
		@else if type-of($option) == string {
			//@debug $option + " is either a unit or min-or-max argument";
			// Is this option possibly a unit?
			@if index($supported-units, $option) {
				//@debug $option + " is a unit";
				$unit: $option;
			}
			@else if index($allowed-min-max, $option) {
				//@debug $option + " is a min-or-max";
				$min-or-max: $option;
			}
			@else {
				@error "get-pspx-width() passed an unsupported string argument (" + $option + ")";
			}
		}
	}

	// Get a size class's width
	@if type-of($min-or-max) != string {
		// If $config-name is null, try to get the size-class from $size-class-context
		@if $config-name == null {
			@if global-variable-exists(size-class-context) and map-has-key($size-class-context, size-class) {
				$config-name: map-get($size-class-context, size-class);
			}
			@else {
				@error "Could not get current size-class from $size-class-context.";
			}
		}
		// Is $config-name a family name?
		@else if size-class-config-has-key(families, $config-name) {
			// Get the size class for this family
			$config-name: size-class-config-get(families, $config-name, size-class);
		}
		// Otherwise, is this not a known size class?
		@else if not size-class-config-has-key(classes, $config-name) {
			@error $config-name + " is neither a known size family or size class name.";
		}

		// Check to see if we have a pspx layout type
		$layout-types: size-class-config-get(options, layout-types);

		@if index($layout-types, pspx) {
			$_return: size-class-config-get(classes, $config-name, pspx, columns) * get-pspx-ratio() / get-config-pspx-ratio();
		} @else {
			@error "Size Class config does not contain a 'pspx' layout type.";
		}
	}
	// Get a breakpoint's min-width or max-width
	@else {
		// If $config-name is null, get the target media query from the current context
		@if $config-name == null {
			@if global-variable-exists(size-class-context) and _susy-deep-has-key($size-class-context, target-media-query, #{$min-or-max}-width) {
				$_return: _susy-deep-get($size-class-context, target-media-query, #{$min-or-max}-width);
			} @else {
				@error "Could not get target-media-query's " + #{$min-or-max}-width + " from $size-class-context.";
			}
		}
			// $config-name is a breakpoint...so let's see if that exists
		@else if size-class-config-has-key(breakpoints, $config-name, #{$min-or-max}-width) {
			// Okay then, try to get the breakpoint config
			$_return: size-class-config-get(breakpoints, $config-name, #{$min-or-max}-width);
		}
		@else {
			@error $config-name + " is not a known breakpoint (or does not have a '" + #{$min-or-max}-width + "' property).";
		}
	}

	// Cover breakpoint value returns
	@if unit($_return) == px {
		// Convert px to unitless value
		$_return: $_return / 1px * get-config-pspx-ratio();
	}

	$_return: _convert-unitless-to-unit($_return, $unit);

	@return $_return;
};

@mixin full-height-max-aspect-ratio($aspect-ratio, $max-height-subtraction: null) {
	@if not global-variable-exists(size-class-context) {
		@error "full-height-max-aspect-ratio() mixin called outside of a size-class() content block.";
	}

	@if $max-height-subtraction == null {
		@if global-variable-exists(size-class-full-height-subtraction) {
			$max-height-subtraction: $size-class-full-height-subtraction;
		} @else {
			$max-height-subtraction: 0;
		}
	}

	@if $max-height-subtraction == 0 {
		max-height: 100vh;
	} @else {
		max-height: calc(100vh - #{$max-height-subtraction});
	}

	// Prevent the element from getting too short
	min-height: 100vw / ($aspect-ratio / 0.5);

	@include limit-raw-vw(height, 100vw / $aspect-ratio);
}

@mixin full-bleed($add-padding: true, $aspect-ratio: null, $important: false) {
	// Load the default config if $size-class-config hasn't already been declared
	@if not global-variable-exists(size-class-config) {
		@include init-size-class-config();
	}

	// Get the outer margin value and apply it as negative left and right margins
	$outer-margin-value: get-outer-margin() * 100% / (100% - get-outer-margin() * 2);

	margin-left: -1 * $outer-margin-value if($important, !important, null);
	margin-right: -1 * $outer-margin-value if($important, !important, null);

	@if $add-padding {
		padding-left: $outer-margin-value if($important, !important, null);
		padding-right: $outer-margin-value if($important, !important, null);
	}

	@if type-of($aspect-ratio) == number {
		@include full-height-max-aspect-ratio($aspect-ratio);
	}
}